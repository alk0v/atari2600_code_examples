

	processor 6502			; вказуємо DASM асемблеру, що система команд буде MOS 6502 
	include "vcs.h"			; підключаємо хедер-файл

	seg						; вказуємо асемблеру створити сегмент даних для нашого картриджу

;------------------------------------------------------
; константи
sprite1_h	equ     16			; висота спрайту

;------------------------------------------------------
; початок оперативної пам'яті (від 0x80 до 0хFF)
			seg.u	vars				; uninitialized segment
			org		$80
sprite_y	ds      1			; вертикальна позиція спрайту

;------------------------------------------------------
; початок блоку пам'яті ROM
	seg		main				; start of main segment
	org $1000				

reset:						; мітка, на яку перейде вказівник команд після ресету
; Первинна ініціалізація - очистка пам'яті та регистрів
    ldx #0
    lda #0
Clear 
    sta 0,x
    inx
    bne Clear
;------------------------------------------------------------------------------------

; Блок 1 - Необмежений по часу. Тут можна робити глобальну ініціалізацію.

    lda #$1E            ; записуємо в акумулятор 1E що відповідає жовтому кольору палітри NTSC
    sta COLUP0          ; зберігаємо це значення в регістр COLUP0 - Color-Luminance Player 0
    lda #$AE            ; зробимо фон блакитним
    sta COLUBK
	lda #2				; нехай стартова позиція спрайта по вертикалі буде 2
	sta sprite_y		; запишемо це значення в комірку пам'яті sprite_y
;------------------------------------------------------------------------------------

skipDrawP0:
    lda #0              ; повернемо 0, якщо не треба малювати графіку спрайта
    beq continueP0

startFrame:
	lda #0               	; записуємо 0 в регістр А (аккумулятор)
	sta VBLANK              ; і зберігаємо його за адресою $0001, що відповідає регістру VBLANK. Це команда TIA перевести промінь на початок першої строки екрану
	lda #2                  ; далі треба дочекатись синхронізації з початком кадру, ставимо 1-й біт в одиницю (00000010 BIN = 2 DEC) 
	sta VSYNC               ; записуємо це значення в регістр VSYNC

	sta WSYNC               ; чекаємо 3 сканлайни для завершення синхронізації кадру
	sta WSYNC				; будь яке значення, записане в регістр WSYNC змушує процесор чекати початку сканлайна
	sta WSYNC               ; то ж можна перевикористати наше 2, яке вже лежить в акумуляторі
	lda #0
    sta VSYNC               ; і вимикаємо вертикальну синхронізацію

;------------------------------------------------------------------------------------
    ; Блок 2 - Маємо 3040 циклів, поки TIA дійде до видимої частини екрану. 

    ; Тут можна робити зміни, однакові для всього кадру.
    inc sprite_y        ; збільшуємо Y координату спрайту кожен кадр

    lda #%00001000      ; 3-й біт відповідає за відзеркалювання спрайту
    sta REFP0

    ;lda #%00000101      ; спрайт подвійної ширини
    lda #%00000110      ; три копії спрайту
    sta NUSIZ0

    ; Позиціонємо спрайт по X
    sta WSYNC
    nop ; 2 машинних цикли
    nop ; +2
    nop ; +2
    nop ; +2
    nop ; +2
    nop ; +2 проходимо horizontal blank
    nop ; 3 пікселі зліва
    nop ; 6 пікселів
    nop ; 12 пікселів
    LDA  #%01010000 ;-5 пікселів
    sta HMP0
    sta RESP0
    sta WSYNC
    sta HMOVE
 ;--------------------------------------------------------------------------------------------------------


    ldx #0					; записуємо 0 в індексний регістр Х
verticalBlank:   
	sta WSYNC               ; чекаємо на початок сканлайну
	inx						; збільшуємо Х на 1 (increment)
	cpx #35                 ; порівнюємо з 35 (compare) 2 WSYNC ми вже витратили вище, тому залишилось 35
	bne verticalBlank       ; якщо не дорівнює, йдемо на мітку verticalBlank

; тут ми нарешті дісталися видимої частини екрану і можемо почати шось на ньому малювати, в нас є на це 192 сканлайни
;---------------------------------------------------------------------------------------------------------------------
	ldx #191                ; визначимо розмір вікна
drawField:
    txa                     ; копіюємо значення індексного регістру в акумулятор
    sec                     ; ставимо флаг переносу
	sbc sprite_y            ; віднімаємо від цього значення поточну координату спрайту
	adc #sprite1_h+1        ; та додаємо висоту спрайту
    bcc skipDrawP0          ; якщо спрацьовує перенос, викликаємо skipDrawP0, а замість паттерну спрайта записуємо нулі
    tay                     ; якщо ні, повертаємо вирахуване значення в регістр Y та беремо його в якості зсуву в пам'яті
    lda Sprite_Triade,y     ; читаємо з пам'яті поточний патерн спрайту
continueP0:
    sta GRP0                ; і записуємо в графічний регістр. Якщо викликалася підпрогама skipDrawP0, вона поверне сюди 0
    sta WSYNC
	dex
	bne drawField

;---------------------------------------------------------------------------------------------------------------------	
; завершаємо кадр, нам треба пропустити ще 30 сканлайнів згідно рекомендації
    lda #%00000010
    sta VBLANK 				; end of screen - enter blanking
	ldx #0					; записуємо 0 в регістр Х
overscan:        
	sta WSYNC				; чекаємо на сканлайн
	inx						; збільшуємо Х на 1
	cpx #30                 ; порівнюємо з 30, якщо ні, повторюємо цикл             
	bne overscan            ;        
	jmp startFrame          ; тут в нас безумовний перехід на початок нового кадру

Sprite_Triade:
    .byte %00000000
	.byte %00001000 ; |    X   |
	.byte %00001000 ; |    X   |
	.byte %00011110 ; |  XXXXX |
	.byte %00011110 ; |  XXXXX |
	.byte %00101010 ; |  X X X |
	.byte %00101010 ; |  X X X |
	.byte %00101010 ; |  X X X |
	.byte %00101010 ; |  X X X |
	.byte %01101011 ; | XX X XX|
	.byte %01101011 ; | XX X XX|
	.byte %01101011 ; | XX X XX|
	.byte %01101011 ; | XX X XX|
	.byte %01100011 ; | XX   XX|
	.byte %01100011 ; | XX   XX|
	.byte %01000001 ; | X     X|
	.byte %01000001 ; | X     X|





;-------------------------------------------------------------------------------------------------------------------------------------------

	org $1ffa               ; в останні 6 байт прошивки картриджа нам треба покласти вектори переривань. Сюди процесор лізе при запуску системи
; всі 3 вектори ведуть на мітку	reset на початку нашого кода
interruptVectors:
	.word reset             ; nmi 
	.word reset             ; reset
	.word reset             ; irq